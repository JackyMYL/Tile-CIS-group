#!/usr/bin/env python
# TimingFlag.py
# Author: Andrew Hard <ahard@uchicago.edu>
# October 11, 2010 
#
# Updated: Joshua Montgomery <Joshua.J.Montgomery@cern.ch>
# Nov 2, 2011 
#
# Major Rewrite: Joshua Montgomery <Joshua.J.Montgomery@cern.ch>:
# Feb 23, 2012:


import argparse
import os.path
import itertools
parser = argparse.ArgumentParser(description=
'This is a macro for identifying unusual timing \n \
behaviors in individual channels.  It has several \n \
functions that are built into pre-existing macros. \n \
The macro calls MapFlagFailure.py, which identifies \n \
channels that are failing the timing flags. \n \
The events for these channels are then checked by GetSamples.py, \n \
which creates a list of failing events to NewTimingCIS.py. \n \
These events can then be checked by using the data with the \n \
NewTimingCIS.py worker or the GetSamples.py worker. \n \
SPECIAL NOTE: Since the validation ntuples have migrated \n \
and are now structured differently from the old h1000 \n \
style ntuples, there are two separate timing scripts. \n \
If the runs you are using are on or before May 31, 2010, \n \
then use the worker \'timingCIS()\', otherwise use the \n \
\'NewTimingCIS()\' worker.', 
formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('--date', action='store', nargs='+', type=str, default='2012-01-01',
                    required=True, help=
  'Select runs to use. If you want to use \n \
a list of run numbers instead, use --ldate. \n \
You have to select SOMETHING for --date, \n \
but it is irrelevant if --ldate is used \n \
(There is probably a better way about that) \n \
Preferred formats: \n \
1) starting date as a string (takes from there \n \
to present). EX: \'YYYY-MM-DD\' \n \
2) runs X days, or X months in the past as string: \n \
   \'-28 days\' or \'-2 months\' \n \
3) All of the runs between two dates. \n \
   This should use two arguments \n \
   each of this form: \'Month DD, YYYY\' \n \
EX: --date 2011-10-01 or --date \'-28 days\' \n \
    --date \'January 01, 2011\' \'February 11, 2011\' \n ')

parser.add_argument('--ldate', action='store', nargs='+', type=int, default=0,
                    help=
'Allows you to select runs to use \n \
by their actual run number. \n \
Run numbers should be separated by whitespace \n \
EX: --listdate 183009 183166 183367 \n ')

parser.add_argument('--region', action='store', nargs='*', type=str, default='',
                    required=True, help=
'Select the regions you wish to examine. \n \
Acceptable formatting is channels as they appear \n \
in the region.GetHash() format separated by spaces. \n \
Entire modules or barrels can be specified by \n \
leaving out the channel information or module and \n \
channel information respectively.\n \n \
EX: --region LBA_m22 EBC_m02_c00 EBA \n \
would produce plots for every channel in LBA22, \n \
every channel in the EBA partition, \n \
and EBC02 channel 00.\n ')

parser.add_argument('--usetime', action='store_true', default=False,
                    help=
'This switch changes the type of plots that are \n \
produced. if set to True, the MapFlagFailure worker \n \
will be utilized allowing results to be filtered \n \
based on quality flags -- but the event-level plots \n \
and amplitude plots (like those generated by investigate) \n \
cannot be produced. This results in faster computation \n \
time and more targeted results. \n \
If set to False the event-level plots will be made \n \
and the results can still be kind of filtered \n \
using the --discretion option, but not for specific \n \
quality flags. This results in a longer computation time. \n \
For more information about this, see the \n \
CIS Calibration Twiki.\n \n')

parser.add_argument('--qflag', action='store', nargs=1, type=str, 
                    default=['Next To Edge Sample'], help=
'Select one CIS Quality Flag you are interested in \n \
investigating. This can be one of 10 flags which \n \
should be a string enclosed in single quotes. \n \
Quality flags should be one of the following: \n \
\'Digital Errors\' \n \
\'Large Injection RMS\' \n \
\'Low Chi2\'\n \
\'Fail Max. Point\' \n \
\'Fail Likely Calib.\' \n \
\'Next To Edge Sample\' \n \
\'Edge Sample\' \n \
\'DB Deviation\' \n \
\'No Response\' \n \
\'all\' \n ')

parser.add_argument('--exclude', action='store_true', default=False,
                    help=
'This is a switch that should be used when \n \
investigating CIS Quality flags. When selected \n \
to be true, this macro will retrieve only \n \
calibrations that pass other flags.\n ')

parser.add_argument('--expert', action='store', nargs=1, type=int, default=[0],
                    help=
'Using this flag you can specify the individual \n \
injection to be plotted by when --timing is set. \n \
Typically it will display the average of \n \
the four identical injections for the specified \n \
DAC and Phase values. It is this average that is \n \
used to compute the amplitude in CIS, but you \n \
specify injection by event number instead of you wish. \n ')

parser.add_argument('--injection', action='store', nargs=3, type=int,
                    default= [0,10,512], help=
'Use this flag to specify the Phase and DAC values \n \
of the injections you are interested in plotting. \n \
There are 3 required integer arguments (in order): \n \
1) Phase \n \
2) DAC (highgain) \n \
3) DAC (lowgain) \n \
Phase should be an integer of steps of 1.7ns. \n \
DACHI should on the order of 10 \n \
DACLO should be on the order of 512 \n \
See twiki for more specific information \n \
regarding DAC injection steps. \n \
Default is 0 10 512. \n \n')

parser.add_argument('--timing', action='store_true', default=False,
                   help=
'This option is used to generate plots from the \n \
NewTimingCIS Module. These include: \n \
1) Fitted Time (ns) VS Injected Charge (pC) \n \
2) Unfitted Single Injection with errors \n \
    (using specified DAC and Phase values) \n \
3) Timing Stack Plots showing fitted time \n \
    as a function of Injected Charge AND Detector Region \n \
The first two are generated for each ADC channel \n \
and run number. The last are two 2D Histograms \n \
per module being examined (high and low gain). \n \
NOTE: --qflag cannot be something other than \n \
a timing flag if this is to work. \n \n')

parser.add_argument('--pulsemap', action='store_true', default=False,
                   help=
'This option can be selected to generate plots \n \
using the PlotPulseShape module. One output is \n \
produced per ADC Channel per Run. The plot shows \n \
the fitted, reconstructedm Injected Pulse shape for \n \
all 7 sampled points of the 60 injections per DAC \n \
value. See the twiki for more information on useage \n \
and example plots. \n \
NOTE: --qflag cannot be something other than \n \
a timing flag if this is to work. \n ')

parser.add_argument('--discretion', action='store_true', default=False,
                   help=
'Selecting this option will filter the results of \n \
--pulsemap and --timing outputs to only include \n \
regions which are failing TIMING-RELATED quality \n \
flags. These include Edge Sample or Next To Edge Sample. \n')

args=parser.parse_args()
if len(args.date) == 1:
    runs             = args.date[0]
elif len(args.date) == 2:
    runs             = (args.date[1], args.date[0])
else:
    print('\
--DATE HAS TOO MANY ARGUMENTS \n \
USING ONLY THE FIRST')
    runs             = args.date[0]
    
selected_region     = args.region
timing_option       = args.usetime
flag                = args.qflag[0]
exclude_other_flags = args.exclude
single_event        = args.expert[0]
phase               = args.injection[0]
dachi               = args.injection[1]
daclo               = args.injection[2]
TNCIS               = args.timing
pulsemap            = args.pulsemap
discretion          = args.discretion
fail_chan_list      = []
examine             = []
event_data          = []

print('USING FLAG:', flag)
print(timing_option)
if timing_option:
    print_amplitude   = False
    print_event       = False
if not timing_option:
    print_amplitude   = True
    print_event       = True    
if discretion:
    NT_showAll        = False
    Timing_Discretion = True
    showAll           = False
#    Discretion        = True
else:
    NT_showAll        = True
    Timing_Discretion = False
    showAll           = True
#    Discretion        = False

if args.ldate:
    runs  = args.ldate

import os
os.chdir(os.getenv('TUCS','.'))
exec(open('src/load.py').read(), globals())



u = Use(run=runs, runType='CIS', region=selected_region)

if timing_option:
    newtimingcis = NewTimingCIS(all=NT_showAll,Phase=phase,dachi=dachi,daclo=daclo, TFlagMacro=True)
else:
    newtimingcis = NewTimingCIS(all=NT_showAll,Phase=phase,dachi=dachi,daclo=daclo, TFlagMacro=False)
    
if not TNCIS:
    newtimingcis = None
    
if flag not in ['Next To Edge Sample', 'Edge Sample'] and Timing_Discretion and TNCIS:
    print('flag and/or discretion inappropriately set if timingCIS output is desired. This may fail')
    
getsamples = GetSamples(all=True, region=selected_region, print_amplitude=print_amplitude, 
            print_event=print_event, single_event=single_event, timing_option=timing_option,
            flagtype=flag, timing_discretion=Timing_Discretion)
            
readbchfromcool = ReadBadChFromCool(schema='OFL', tag='UPD4', Fast=True, storeADCinfo=True)
readcalfromcool = ReadCalibFromCool(schema='OFL', runType='CIS', folder='CALIB/CIS', tag='UPD4', data = 'DATA')

if pulsemap:
    cisflagpro_m   = CISFlagProcedure_modified()
    cisrecalpro    = CISRecalibrateProcedure()
    plotpulseshape = PlotPulseShape(all=showAll, region=selected_region, discretion=Timing_Discretion)
else:
    cisflagpro_m   = None
    cisrecalpro    = None
    plotpulseshape = None

    
Go([
    u,\
    ReadCIS(),\
    CleanCIS(),\
    readbchfromcool,\
    readcalfromcool,\
    cisflagpro_m,\
    cisrecalpro,\
    MoreInfo(),\
    MapFlagFailure(exclude_other_flags=exclude_other_flags, flagtype=flag),\
    getsamples,\
    plotpulseshape,\
    newtimingcis,\
    ])
